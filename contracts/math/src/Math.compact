// SPDX-License-Identifier: MIT
pragma language_version >= 0.14.0;

/**
 * @description A utility module providing mathematical operations for 64-bit unsigned integers
 * (Uint<64>) in the range [0, 2^64 - 1]. The module supports arithmetic, division, square root,
 * and utility functions with overflow and underflow checks where applicable.
 *
 * Supported Mathematical Operations:
 * - Arithmetic:
 *   - add(): Adds two Uint<64> numbers, checking for overflow.
 *   - sub(): Subtracts one Uint<64> number from another, checking for underflow.
 *   - mul(): Multiplies two Uint<64> numbers, returning a Uint<128> result.
 * - Division:
 *   - div(): Computes the quotient of dividing one Uint<64> number by another.
 *   - rem(): Computes the remainder of dividing one Uint<64> number by another.
 * - Square Root:
 *   - sqrt(): Computes the floor of the square root of a Uint<64> number using the Newton-Raphson method.
 * - Utility:
 *   - isMultiple(): Checks if one Uint<64> number is a multiple of another.
 *   - min(): Returns the smaller of two Uint<64> numbers.
 *   - max(): Returns the larger of two Uint<64> numbers.
 */
module Math {
    import CompactStandardLibrary;

    import "./interfaces/IMath";

    import Max prefix Max_; 

    /**
     * @description Adds two Uint<64> numbers, checking for overflow.
     */
    export circuit add(a: Uint<64>, b: Uint<64>): Uint<64> {
        const result = a + b;
        assert (result <= Max_U64()) "Math: addition overflow";
        return result as Uint<64>;
    }

    /**
     * @description Subtracts b from a, checking for underflow.
     */
    export circuit sub(a: Uint<64>, b: Uint<64>): Uint<64> {
        assert (a >= b) "Math: subtraction underflow";
        return a - b;
    }

    /**
     * @description Multiplies two Uint<64> values, returning a Uint<128> result.
     */
    export circuit mul(a: Uint<64>, b: Uint<64>): Uint<128> {
        return a * b;
    }

    /**
     * @description Divides a Uint<64> a by b, returning quotient.
     */
    export circuit div(a: Uint<64>, b: Uint<64>): Uint<64> {
        assert (b > 0) "Math: division by zero";
        const result = divLocally(a, b);
        assert (result.remainder < b) "Math: remainder error";
        assert ((result.quotient * b + result.remainder) as Uint<64> == a) "Math: division invalid";
        return result.quotient;
    }

    /**
     * @description Computes the remainder of dividing a by b.
     */
    export circuit rem(a: Uint<64>, b: Uint<64>): Uint<64> {
        assert (b > 0) "Math: division by zero";
        const result = divLocally(a, b);
        assert (result.remainder < b) "Math: remainder error";
        assert ((result.quotient * b + result.remainder) as Uint<64> == a) "Math: division invalid";
        return result.remainder;
    }

    /**
     * @description Computes the square root of a Uint<64> value, verified on-chain.
     */
    export circuit sqrt(radicand: Uint<64>): Uint<64> {
        const root = sqrtLocally(radicand);
        assert (mul(root, root) <= radicand) "Math: sqrt overestimate (root² > radicand)";
        assert (mul(add(root, 1), add(root, 1)) as Field as Uint<128> > radicand as Field as Uint<128>) "Math: sqrt underestimate (next root still ≤ radicand)";
        return root;
    }

    /**
     * @description Checks if a number is a multiple of another.
     */
    export circuit isMultiple(value: Uint<64>, b: Uint<64>): Boolean {
        assert (b > 0) "Math: division by zero";
        return rem(value, b) == 0;
    }

    /**
     * @description Returns the minimum of two Uint<64> values.
     */
    export circuit min(a: Uint<64>, b: Uint<64>): Uint<64> {
        return a < b ? a : b;
    }

    /**
     * @description Returns the maximum of two Uint<64> values.
     */
    export circuit max(a: Uint<64>, b: Uint<64>): Uint<64> {
        return a > b ? a : b;
    }
}
