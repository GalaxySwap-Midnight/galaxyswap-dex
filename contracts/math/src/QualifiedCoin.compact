pragma language_version >= 0.15.0;

/**
 * @title QualifiedCoin module
 * @description Utility functions for working with QualifiedCoinInfo types.
 * Includes conversion functions and comparison operations for qualified coins based on value and color.
 * 
 * @remarks
 * This module provides a complete set of utilities for qualified coin manipulation and comparison.
 * Comparison operations can be based on coin values (bigint) or colors (Bytes<32>).
 * All functions are designed to work with the QualifiedCoinInfo type, preserving the mt_index.
 * 
 * Supported Operations:
 * - Conversions:
 *   - fromQCoin(): Converts CoinInfo to QualifiedCoinInfo by adding mt_index.
 *   - toQCoin(): Converts QualifiedCoinInfo to CoinInfo by removing mt_index.
 * - Value-based Comparisons (require same color):
 *   - eqValue(): Checks if two coins have equal values.
 *   - ltValue(): Checks if one coin's value is less than another's.
 *   - lteValue(): Checks if one coin's value is less than or equal to another's.
 *   - gtValue(): Checks if one coin's value is greater than another's.
 *   - gteValue(): Checks if one coin's value is greater than or equal to another's.
 * - Color-based Comparisons:
 *   - eqColor(): Checks if two coins have equal colors.
 *   - ltColor(): Checks if one coin's color is less than another's (lexicographic).
 *   - lteColor(): Checks if one coin's color is less than or equal to another's.
 *   - gtColor(): Checks if one coin's color is greater than another's.
 *   - gteColor(): Checks if one coin's color is greater than or equal to another's.
 * - Combined Comparisons:
 *   - eq(): Checks if two coins are completely equal (value, color, nonce, and mt_index).
 *   - isSameColor(): Checks if two coins have the same color.
 *   - isSameValue(): Checks if two coins have the same value.
 * - Arithmetic Operations (require same color):
 *   - add(): Adds the values of two coins with the same color.
 *   - sub(): Subtracts the value of the second coin from the first coin with the same color.
 *   - mul(): Multiplies the values of two coins with the same color.
 *   - div(): Divides the value of the first coin by the second coin with the same color.
 *   - divRem(): Divides the value of the first coin by the second coin with the same color, returning both quotient and remainder.
 *   - rem(): Computes the remainder when dividing the value of the first coin by the second coin with the same color.
 *   - sqrt(): Computes the square root of a coin's value.
 *   - min(): Returns the coin with the minimum value among two coins with the same color.
 *   - max(): Returns the coin with the maximum value among two coins with the same color.
 * - Sorting Operations:
 *   - sortGtByColor(): Sorts two coins in descending order (greater to lesser) based on their colors.
 *   - sortLtByColor(): Sorts two coins in ascending order (lesser to greater) based on their colors.
 *   - sortGtByValue(): Sorts two coins in descending order (greater to lesser) based on their values (requires same color).
 *   - sortLtByValue(): Sorts two coins in ascending order (lesser to greater) based on their values (requires same color).
 */
module QualifiedCoin {
    import CompactStandardLibrary;

    import "./interfaces/IQualifiedCoin";

    import Bytes32 prefix Bytes32_;
    import MathU128 prefix MathU128_; 
    
    /**
     * @title fromQCoin circuit
     * @description Converts CoinInfo to QualifiedCoinInfo by adding mt_index.
     * 
     * @remarks
     * This function takes a CoinInfo and adds a merkle tree index to create a QualifiedCoinInfo.
     * The mt_index is typically used to track the position of the coin in a merkle tree.
     *
     * @param {CoinInfo} coin - The coin information to convert.
     * @param {Uint<64>} mt_index - The merkle tree index for the coin.
     *
     * @returns {QualifiedCoinInfo} - The qualified coin information with mt_index.
     */
    export circuit fromQCoin(coin: CoinInfo, mt_index: Uint<64>): QualifiedCoinInfo {
        return QualifiedCoinInfo {
            nonce: coin.nonce,
            color: coin.color,
            value: coin.value,
            mt_index: mt_index
        };
    }

    /**
     * @title toQCoin circuit
     * @description Converts QualifiedCoinInfo to CoinInfo by removing mt_index.
     * 
     * @remarks
     * This function takes a QualifiedCoinInfo and removes the mt_index to create a CoinInfo.
     * This is useful when you need to work with the basic coin information without the merkle tree context.
     *
     * @param {QualifiedCoinInfo} qualifiedCoin - The qualified coin information to convert.
     *
     * @returns {CoinInfo} - The basic coin information without mt_index.
     */
    export circuit toQCoin(qualifiedCoin: QualifiedCoinInfo): CoinInfo {
        return CoinInfo {
            nonce: qualifiedCoin.nonce,
            color: qualifiedCoin.color,
            value: qualifiedCoin.value
        };
    }

    /**
     * @title eqValue circuit
     * @description Compares two qualified coins for equal values.
     * 
     * @remarks
     * This function compares only the value field of two qualified coins, regardless of their color, nonce, or mt_index.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if the coins have equal values, false otherwise.
     * 
     * @throws {Error} "QualifiedCoin: eqValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit eqValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        assert (eqColor(a, b)) "QualifiedCoin: eqValue() - colors must be the same";
        return a.value == b.value;
    }

    /**
     * @title ltValue circuit
     * @description Compares two qualified coins for less than value.
     * 
     * @remarks
     * This function compares only the value field of two qualified coins using less than comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.value < b.value, false otherwise.
     * 
     * @throws {Error} "QualifiedCoin: ltValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit ltValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        assert (eqColor(a, b)) "QualifiedCoin: ltValue() - colors must be the same";
        return a.value < b.value;
    }

    /**
     * @title lteValue circuit
     * @description Compares two qualified coins for less than or equal value.
     * 
     * @remarks
     * This function compares only the value field of two qualified coins using less than or equal comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.value <= b.value, false otherwise.
     * 
     * @throws {Error} "QualifiedCoin: lteValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit lteValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        assert (eqColor(a, b)) "QualifiedCoin: lteValue() - colors must be the same";
        return a.value <= b.value;
    }

    /**
     * @title gtValue circuit
     * @description Compares two qualified coins for greater than value.
     * 
     * @remarks
     * This function compares only the value field of two qualified coins using greater than comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.value > b.value, false otherwise.
     * 
     * @throws {Error} "QualifiedCoin: gtValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit gtValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        assert (eqColor(a, b)) "QualifiedCoin: gtValue() - colors must be the same";
        return a.value > b.value;
    }

    /**
     * @title gteValue circuit
     * @description Compares two qualified coins for greater than or equal value.
     * 
     * @remarks
     * This function compares only the value field of two qualified coins using greater than or equal comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.value >= b.value, false otherwise.
     * 
     * @throws {Error} "QualifiedCoin: gteValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit gteValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        assert (eqColor(a, b)) "QualifiedCoin: gteValue() - colors must be the same";
        return a.value >= b.value;
    }

    /**
     * @title eqColor circuit
     * @description Compares two qualified coins for equal colors.
     * 
     * @remarks
     * This function compares only the color field of two qualified coins using Bytes32 equality.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if the coins have equal colors, false otherwise.
     */
    export circuit eqColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return Bytes32_eq(a.color, b.color);
    }

    /**
     * @title ltColor circuit
     * @description Compares two qualified coins for less than color (lexicographic).
     * 
     * @remarks
     * This function compares only the color field of two qualified coins using Bytes32 less than comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.color < b.color (lexicographic), false otherwise.
     */
    export circuit ltColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return Bytes32_lt(a.color, b.color);
    }

    /**
     * @title lteColor circuit
     * @description Compares two qualified coins for less than or equal color.
     * 
     * @remarks
     * This function compares only the color field of two qualified coins using Bytes32 less than or equal comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.color <= b.color, false otherwise.
     */
    export circuit lteColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return Bytes32_lte(a.color, b.color);
    }

    /**
     * @title gtColor circuit
     * @description Compares two qualified coins for greater than color.
     * 
     * @remarks
     * This function compares only the color field of two qualified coins using Bytes32 greater than comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.color > b.color, false otherwise.
     */
    export circuit gtColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return Bytes32_gt(a.color, b.color);
    }

    /**
     * @title gteColor circuit
     * @description Compares two qualified coins for greater than or equal color.
     * 
     * @remarks
     * This function compares only the color field of two qualified coins using Bytes32 greater than or equal comparison.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if a.color >= b.color, false otherwise.
     */
    export circuit gteColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return Bytes32_gte(a.color, b.color);
    }

    /**
     * @title eq circuit
     * @description Compares two qualified coins for complete equality (value, color, nonce, and mt_index).
     * 
     * @remarks
     * This function compares all fields of two qualified coins for complete equality.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if all fields are equal, false otherwise.
     */
    export circuit eq(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return eqValue(a, b) && eqColor(a, b) && Bytes32_eq(a.nonce, b.nonce) && a.mt_index == b.mt_index;
    }

    /**
     * @title add circuit
     * @description Adds the values of two qualified coins with the same color.
     * 
     * @remarks
     * This function adds the values of two qualified coins, asserting that they have the same color.
     * The result is a new qualified coin with the same color, nonce, and mt_index as the first coin, but with the summed value.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to add.
     * @param {QualifiedCoinInfo} b - Second qualified coin to add.
     *
     * @returns {QualifiedCoinInfo} - A new qualified coin with the same color, nonce, and mt_index as 'a', but with value = a.value + b.value.
     * 
     * @throws {Error} "QualifiedCoin: add() - colors must be the same" - When the coins have different colors.
     */
    export circuit add(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: add() - colors must be the same";
        const sum = MathU128_addChecked(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: sum,
            mt_index: a.mt_index
        };
    }

    /**
     * @title sub circuit
     * @description Subtracts the value of the second qualified coin from the first qualified coin with the same color.
     * 
     * @remarks
     * This function subtracts the values of two qualified coins, asserting that they have the same color.
     * The result is a new qualified coin with the same color, nonce, and mt_index as the first coin, but with the difference value.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin (minuend).
     * @param {QualifiedCoinInfo} b - Second qualified coin (subtrahend).
     *
     * @returns {QualifiedCoinInfo} - A new qualified coin with the same color, nonce, and mt_index as 'a', but with value = a.value - b.value.
     * 
     * @throws {Error} "QualifiedCoin: sub() - colors must be the same" - When the coins have different colors.
     * @throws {Error} "QualifiedCoin: sub() - result would be negative" - When b.value > a.value.
     */
    export circuit sub(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: sub() - colors must be the same";
        assert (gteValue(a, b)) "QualifiedCoin: sub() - result would be negative";
        const difference = MathU128_sub(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: difference,
            mt_index: a.mt_index
        };
    }

    /**
     * @title mul circuit
     * @description Multiplies the values of two qualified coins with the same color.
     * 
     * @remarks
     * This function multiplies the values of two qualified coins, asserting that they have the same color.
     * The result is a new qualified coin with the same color, nonce, and mt_index as the first coin, but with the product value.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to multiply.
     * @param {QualifiedCoinInfo} b - Second qualified coin to multiply.
     *
     * @returns {QualifiedCoinInfo} - A new qualified coin with the same color, nonce, and mt_index as 'a', but with value = a.value * b.value.
     * 
     * @throws {Error} "QualifiedCoin: mul() - colors must be the same" - When the coins have different colors.
     */
    export circuit mul(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: mul() - colors must be the same";
        const product = MathU128_mulChecked(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: product,
            mt_index: a.mt_index
        };
    }

    /**
     * @title div circuit
     * @description Divides the value of the first qualified coin by the second qualified coin with the same color.
     * 
     * @remarks
     * This function divides the values of two qualified coins, asserting that they have the same color.
     * The result is a new qualified coin with the same color, nonce, and mt_index as the first coin, but with the quotient value.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin (dividend).
     * @param {QualifiedCoinInfo} b - Second qualified coin (divisor).
     *
     * @returns {QualifiedCoinInfo} - A new qualified coin with the same color, nonce, and mt_index as 'a', but with value = a.value / b.value.
     * 
     * @throws {Error} "QualifiedCoin: div() - colors must be the same" - When the coins have different colors.
     * @throws {Error} "QualifiedCoin: div() - division by zero" - When b.value is zero.
     */
    export circuit div(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: div() - colors must be the same";
        assert (b.value != 0) "QualifiedCoin: div() - division by zero";
        const quotient = MathU128_div(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: quotient,
            mt_index: a.mt_index
        };
    }
 
    /**
     * @title divRem circuit
     * @description Divides the value of the first qualified coin by the second qualified coin with the same color, returning both quotient and remainder.
     * 
     * @remarks
     * This function divides the values of two qualified coins, asserting that they have the same color.
     * Returns a struct containing both the quotient and remainder qualified coins.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin (dividend).
     * @param {QualifiedCoinInfo} b - Second qualified coin (divisor).
     *
     * @returns {DivRemResult} - A struct containing quotient and remainder qualified coins.
     * 
     * @throws {Error} "QualifiedCoin: divRem() - colors must be the same" - When the coins have different colors.
     * @throws {Error} "QualifiedCoin: divRem() - division by zero" - When b.value is zero.
     */
    export circuit divRem(a: QualifiedCoinInfo, b: QualifiedCoinInfo): DivResultQualifiedCoin {
        assert (eqColor(a, b)) "QualifiedCoin: divRem() - colors must be the same";
        assert (b.value != 0) "QualifiedCoin: divRem() - division by zero";
        const divResult = MathU128_divRem(a.value, b.value);
        return DivResultQualifiedCoin {
            quotient: QualifiedCoinInfo {
                nonce: a.nonce,
                color: a.color,
                value: MathU128_fromU128(divResult.quotient),
                mt_index: a.mt_index
            },
            remainder: QualifiedCoinInfo {
                nonce: a.nonce,
                color: a.color,
                value: MathU128_fromU128(divResult.remainder),
                mt_index: a.mt_index
            }
        };
    }

    /**
     * @title rem circuit
     * @description Computes the remainder when dividing the value of the first qualified coin by the second qualified coin with the same color.
     * 
     * @remarks
     * This function computes the remainder of division, asserting that the qualified coins have the same color.
     * The result is a new qualified coin with the same color, nonce, and mt_index as the first coin, but with the remainder value.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin (dividend).
     * @param {QualifiedCoinInfo} b - Second qualified coin (divisor).
     *
     * @returns {QualifiedCoinInfo} - A new qualified coin with the same color, nonce, and mt_index as 'a', but with value = a.value % b.value.
     * 
     * @throws {Error} "QualifiedCoin: rem() - colors must be the same" - When the coins have different colors.
     * @throws {Error} "QualifiedCoin: rem() - division by zero" - When b.value is zero.
     */
    export circuit rem(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: rem() - colors must be the same";
        assert (b.value != 0) "QualifiedCoin: rem() - division by zero";
        const remainder = MathU128_rem(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: remainder,
            mt_index: a.mt_index
        };
    }

    /**
     * @title sqrt circuit
     * @description Computes the square root of a qualified coin's value.
     * 
     * @remarks
     * This function computes the square root of a qualified coin's value using MathU128_sqrt.
     * The result is a new qualified coin with the same color, nonce, and mt_index as the input coin, but with the square root value.
     *
     * @param {QualifiedCoinInfo} a - The qualified coin to compute the square root of.
     *
     * @returns {QualifiedCoinInfo} - A new qualified coin with the same color, nonce, and mt_index as 'a', but with value = sqrt(a.value).
     */
    export circuit sqrt(a: QualifiedCoinInfo): QualifiedCoinInfo {
        const sqrtValue = MathU128_sqrt(a.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: sqrtValue,
            mt_index: a.mt_index
        };
    }

    /**
     * @title min circuit
     * @description Returns the qualified coin with the minimum value among two qualified coins with the same color.
     * 
     * @remarks
     * This function compares the values of two qualified coins, asserting that they have the same color.
     * Returns the qualified coin with the smaller value, maintaining the same color, nonce, and mt_index as the first coin.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {QualifiedCoinInfo} - The qualified coin with the smaller value, same color, nonce, and mt_index as 'a'.
     * 
     * @throws {Error} "QualifiedCoin: min() - colors must be the same" - When the coins have different colors.
     */
    export circuit min(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: min() - colors must be the same";
        const minValue = MathU128_min(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: minValue,
            mt_index: a.mt_index
        };
    }

    /**
     * @title max circuit
     * @description Returns the qualified coin with the maximum value among two qualified coins with the same color.
     * 
     * @remarks
     * This function compares the values of two qualified coins, asserting that they have the same color.
     * Returns the qualified coin with the larger value, maintaining the same color, nonce, and mt_index as the first coin.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {QualifiedCoinInfo} - The qualified coin with the larger value, same color, nonce, and mt_index as 'a'.
     * 
     * @throws {Error} "QualifiedCoin: max() - colors must be the same" - When the coins have different colors.
     */
    export circuit max(a: QualifiedCoinInfo, b: QualifiedCoinInfo): QualifiedCoinInfo {
        assert (eqColor(a, b)) "QualifiedCoin: max() - colors must be the same";
        const maxValue = MathU128_max(a.value, b.value);
        return QualifiedCoinInfo {
            nonce: a.nonce,
            color: a.color,
            value: maxValue,
            mt_index: a.mt_index
        };
    }

    /**
     * @title sortGtByColor circuit
     * @description Sorts two qualified coins in descending order (greater to lesser) based on their colors.
     * 
     * @remarks
     * This function sorts two qualified coins by their colors in descending order (lexicographic).
     * Returns a tuple where the first element has the greater color and the second has the lesser color.
     * If the colors are equal, the order remains unchanged.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to sort.
     * @param {QualifiedCoinInfo} b - Second qualified coin to sort.
     *
     * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - A tuple with qualified coins sorted in descending order by color.
     */
    export circuit sortGtByColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): [QualifiedCoinInfo, QualifiedCoinInfo] {
        if (gtColor(a, b)) {
            return [a, b];
        } else {
            return [b, a];
        }
    }

    /**
     * @title sortLtByColor circuit
     * @description Sorts two qualified coins in ascending order (lesser to greater) based on their colors.
     * 
     * @remarks
     * This function sorts two qualified coins by their colors in ascending order (lexicographic).
     * Returns a tuple where the first element has the lesser color and the second has the greater color.
     * If the colors are equal, the order remains unchanged.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to sort.
     * @param {QualifiedCoinInfo} b - Second qualified coin to sort.
     *
     * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - A tuple with qualified coins sorted in ascending order by color.
     */
    export circuit sortLtByColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): [QualifiedCoinInfo, QualifiedCoinInfo] {
        if (ltColor(a, b)) {
            return [a, b];
        } else {
            return [b, a];
        }
    } 

    /**
     * @title sortGtByValue circuit
     * @description Sorts two qualified coins in descending order (greater to lesser) based on their values.
     * 
     * @remarks
     * This function sorts two qualified coins with the same color by their values in descending order.
     * Returns a tuple where the first element has the greater value and the second has the lesser value.
     * If the values are equal, the order remains unchanged.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to sort.
     * @param {QualifiedCoinInfo} b - Second qualified coin to sort.
     *
     * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - A tuple with qualified coins sorted in descending order by value.
     * 
     * @throws {Error} "QualifiedCoin: sortGtByValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit sortGtByValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): [QualifiedCoinInfo, QualifiedCoinInfo] {
        assert (eqColor(a, b)) "QualifiedCoin: sortGtByValue() - colors must be the same";
        if (gtValue(a, b)) {
            return [a, b];
        } else {
            return [b, a];
        }
    }

    /**
     * @title sortLtByValue circuit
     * @description Sorts two qualified coins in ascending order (lesser to greater) based on their values.
     * 
     * @remarks
     * This function sorts two qualified coins with the same color by their values in ascending order.
     * Returns a tuple where the first element has the lesser value and the second has the greater value.
     * If the values are equal, the order remains unchanged.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to sort.
     * @param {QualifiedCoinInfo} b - Second qualified coin to sort.
     *
     * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - A tuple with qualified coins sorted in ascending order by value.
     * 
     * @throws {Error} "QualifiedCoin: sortLtByValue() - colors must be the same" - When the coins have different colors.
     */
    export circuit sortLtByValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): [QualifiedCoinInfo, QualifiedCoinInfo] {
        assert (eqColor(a, b)) "QualifiedCoin: sortLtByValue() - colors must be the same";
        if (ltValue(a, b)) {
            return [a, b];
        } else {
            return [b, a];
        }
    }

    /**
     * @title isSameColor circuit
     * @description Checks if two qualified coins have the same color.
     * 
     * @remarks
     * This is an alias for eqColor for better semantic clarity.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if the coins have the same color, false otherwise.
     */
    export circuit isSameColor(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return eqColor(a, b);
    }

    /**
     * @title isSameValue circuit
     * @description Checks if two qualified coins have the same value.
     * 
     * @remarks
     * This is an alias for eqValue for better semantic clarity.
     *
     * @param {QualifiedCoinInfo} a - First qualified coin to compare.
     * @param {QualifiedCoinInfo} b - Second qualified coin to compare.
     *
     * @returns {Boolean} - True if the coins have the same value, false otherwise.
     */
    export circuit isSameValue(a: QualifiedCoinInfo, b: QualifiedCoinInfo): Boolean {
        return eqValue(a, b);
    }
} 