pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export {Maybe, CoinInfo, MerkleTreePath, ZswapCoinPublicKey}

export enum Role {
    Admin,
    Lp,
    Trader,
    None
};

// Public state
export ledger roleCommits: MerkleTree<10, Bytes<32>>;

// Private state
witness getRole(user: ZswapCoinPublicKey): Role;
witness updateRole(userRoleCommit: Bytes<32>, user: ZswapCoinPublicKey, role: Role): [];
witness getRolePath(userRoleCommit: Bytes<32>): Maybe<MerkleTreePath<10, Bytes<32>>>;

constructor(initialAdmin: ZswapCoinPublicKey) {
    const adminRoleCommit = hashRole(initialAdmin, Role.Admin);

    roleCommits.insert(adminRoleCommit);
    
    return updateRole(adminRoleCommit, initialAdmin, Role.Admin);
}

export circuit addRole(user: ZswapCoinPublicKey, role: Role): [] {
    assert (onlyAdmin()) "RoleError: Caller does not have an Admin role.";
    assert (roleCommits.is_full() == false) "RoleError: Role commitments tree is full!";

    const userRoleCommit = hashRole(user, role);

    roleCommits.insert(userRoleCommit);
    
    return updateRole(userRoleCommit, user, role);
}

export circuit hashRole(user: ZswapCoinPublicKey, role: Role): Bytes<32> {
    const roleHash = persistent_hash<Vector<1, Role>>([role]);
    return persistent_hash<Vector<2, Bytes<32>>>([user.bytes, roleHash]);
}

export circuit onlyAdmin(): Boolean {
    return hasRole(Role.Admin);
}

export circuit onlyLp(): Boolean {
    return hasRole(Role.Lp);
}

export circuit onlyTrader(): Boolean {
    return hasRole(Role.Trader); 
}

export circuit hasRole(role: Role): Boolean {
    const caller = own_public_key();

    const userRoleCommit = hashRole(caller, role);
    const userRolePath = getRolePath(userRoleCommit);

    assert (
        userRolePath.is_some && 
        roleCommits.check_root(getPathRoot(userRolePath.value)) &&
        userRoleCommit == userRolePath.value.leaf
    ) "RoleError: Unauthorized action!";    

    return true;
}

// TODO move that to utils.compact
circuit getPathRoot(path: MerkleTreePath<10, Bytes<32>>): MerkleTreeDigest {
    return merkle_tree_path_root<10, Bytes<32>>(path);
}
