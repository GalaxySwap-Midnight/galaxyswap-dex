pragma language_version >= 0.14.0;

/**
 * @title LunarswapFactory
 * @description Factory contract for creating and managing trading pairs in the Lunarswap protocol.
 * 
 * @remarks
 * The LunarswapFactory is responsible for the creation, storage, and management of all trading pairs
 * in the protocol. It implements a factory pattern where each unique token pair has a corresponding
 * pair contract that handles the actual trading logic and liquidity management.
 * 
 * Key Features:
 * - Pair creation and initialization
 * - Pair storage and retrieval
 * - Reserve management and updates
 * - Deterministic pair identification through token sorting
 */
module LunarswapFactory {
    import CompactStandardLibrary;

    import "./openzeppelin/Utils" prefix Utils_;

    import "./interfaces/ILunarswapPair";
    import "./interfaces/ILunarswapFactory";

    import LunarswapPair prefix LunarswapPair_;  
    import LunarswapLibrary prefix LunarswapLibrary_;

    /**
     * @title initialize circuit
     * @description Initializes the Lunarswap factory with LP token configuration.
     * 
     * @remarks
     * This circuit sets up the initial configuration for LP tokens including name,
     * symbol, decimals, and nonce. It should only be called once during contract deployment.
     *
     * @circuitInfo k=11, rows=1200
     *
     * @param {Bytes<32>} lpTokenNonce      - The nonce for LP token generation.
     * @param {Opaque<"string">} lpTokenName - The name of the LP token.
     * @param {Opaque<"string">} lpTokenSymbol - The symbol of the LP token.
     * @param {Uint<8>} lpTokenDecimals     - The number of decimals for LP tokens.
     *
     * @returns [] - No return values.
     */
    export circuit initialize(
        lpTokenNonce: Bytes<32>,
        lpTokenName: Opaque<"string">,
        lpTokenSymbol: Opaque<"string">,
        lpTokenDecimals: Uint<8>
    ): [] {
        return LunarswapPair_initialize(lpTokenNonce, lpTokenName, lpTokenSymbol, lpTokenDecimals);
    }

    /**
     * @title getAllPairLength circuit
     * @description Returns the total number of trading pairs in the factory.
     * 
     * @remarks
     * This circuit provides a count of all registered trading pairs stored in the liquidity pool.
     *
     * @circuitInfo k=11, rows=300
     *
     * @returns {Uint<64>} - The total number of trading pairs.
     */
    export circuit getAllPairLength(): Uint<64> {
        return pool.size();
    }
    
    /**
     * @title isIdentityExists circuit
     * @description Checks if a trading pair exists for the given identity hash.
     * 
     * @remarks
     * This circuit verifies whether a pair with the specified identity hash exists
     * in the liquidity pool.
     *
     * @circuitInfo k=11, rows=400
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     *
     * @returns {Boolean} - True if the pair exists, false otherwise.
     */
    export circuit isIdentityExists(identity: Bytes<32>): Boolean {
        return pool.member(identity);
    } 

    /**
     * @title getPair circuit
     * @description Retrieves the pair information for a given identity hash.
     * 
     * @remarks
     * This circuit returns the complete pair data including reserves and metadata.
     * The pair must exist for this circuit to succeed.
     *
     * @circuitInfo k=11, rows=600
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     *
     * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
     *
     * @returns {Pair} - The pair information including reserves and metadata.
     */
    export circuit getPair(identity: Bytes<32>): Pair {
        assert (isIdentityExists(identity)) "LunarswapFactory: getPair() - Pair does not exist";
        return pool.lookup(identity);
    }

    /**
     * @title getReserves circuit
     * @description Returns the current reserves for a trading pair.
     * 
     * @remarks
     * This circuit retrieves the reserves for a pair identified by its identity hash
     * and token information. The reserves are returned in the order of token0 and token1.
     *
     * @circuitInfo k=11, rows=800
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Bytes<32>} reserve0Type - The type of the first reserve.
     * @param {Bytes<32>} reserve1Type - The type of the second reserve.
     *
     * @throws {Error} "LunarswapFactory: getPair() - Pair does not exist" if the pair doesn't exist.
     *
     * @returns {[QualifiedCoinInfo, QualifiedCoinInfo]} - The reserves for token0 and token1 respectively.
     */
    export circuit getReserves(identity: Bytes<32>, reserve0Type: Bytes<32>, reserve1Type: Bytes<32>): [QualifiedCoinInfo, QualifiedCoinInfo] {
        assert (isIdentityExists(identity)) "LunarswapFactory: getReserves() - Pair does not exist";
        assert (reserves.member(reserve0Type)) "LunarswapFactory: getReserves() - Reserve0 does not exist";
        assert (reserves.member(reserve1Type)) "LunarswapFactory: getReserves() - Reserve1 does not exist";
        const reserve0 = reserves.lookup(reserve0Type);
        const reserve1 = reserves.lookup(reserve1Type);
        return [reserve0, reserve1];
    }

    /**
     * @title addReserves circuit
     * @description Adds the reserves for a given pair identity with new token0 and token1 CoinInfo.
     *
     * @param {Bytes<32>} reserve0Type - The type of the first reserve.
     * @param {Bytes<32>} reserve1Type - The type of the second reserve.
     * @param {CoinInfo} token0    - The first token's CoinInfo.
     * @param {CoinInfo} token1    - The second token's CoinInfo.
     *
     * @returns [] - No return values.
     */
    export circuit addReserves(reserve0Type: Bytes<32>, reserve1Type: Bytes<32>, token0: CoinInfo, token1: CoinInfo): [] {
        // This condition is a must because when initially depositing liquidity, the reserves are undefined.
        if (!reserves.member(reserve0Type) && !reserves.member(reserve1Type)) {
            reserves.insert_coin(reserve0Type, token0, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
            reserves.insert_coin(reserve1Type, token1, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
            return [];
        }

        if (reserves.lookup(reserve0Type).value == 0) {
            reserves.insert_coin(reserve0Type, token0, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
        } else {
            reserves.insert_coin(
                reserve0Type,
                merge_coin_immediate(
                    reserves.lookup(reserve0Type),
                    token0
                ),
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        }

        if (reserves.lookup(reserve1Type).value == 0) {
            reserves.insert_coin(reserve1Type, token1, right<ZswapCoinPublicKey, ContractAddress>(kernel.self()));
        } else {
            reserves.insert_coin(
                reserve1Type,
                merge_coin_immediate(
                    reserves.lookup(reserve1Type),
                    token1
                ),
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        }
        return [];
    }

    /**
     * @title removeReserves circuit
     * @description Removes the reserves for a given pair identity with new token0 and token1 CoinInfo.
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {Bytes<32>} reserve0Type - The type of the first reserve.
     * @param {Bytes<32>} reserve1Type - The type of the second reserve.
     * @param {Uint<128>} amount0 - The amount of token0 to remove.
     * @param {Uint<128>} amount1 - The amount of token1 to remove.
     * @param {Either<ZswapCoinPublicKey, ContractAddress>} to - The recipient of the removed tokens.
     *
     * @returns [] - No return values.
     */
    export circuit removeReserves(
        identity: Bytes<32>,
        reserve0Type: Bytes<32>,
        reserve1Type: Bytes<32>,
        amount0: Uint<128>,
        amount1: Uint<128>,
        to: Either<ZswapCoinPublicKey, ContractAddress>
    ): [] {
        const [reserve0, reserve1] = getReserves(identity, reserve0Type, reserve1Type);
        send(reserve0, to, amount0);
        send(reserve1, to, amount1);
        return [];
    }

    /**
     * @title swapReserves circuit
     * @description Swaps reserves between two tokens for a given pair identity.
     *
     * @remarks
     * This circuit allows updating the reserves for a pair by either adding to the reserve
     * of `tokenIn` if its value is greater than zero, or sending out from the reserve of
     * `tokenOut` if its value is greater than zero.
     *
     * @param {Bytes<32>} identity - The unique identity hash of the pair.
     * @param {CoinInfo} tokenIn   - The input token information (to add to reserves).
     * @param {CoinInfo} tokenOut  - The output token information (to remove from reserves).
     *
     * @returns [] - No return values.
     */
    export circuit swapReserves(
        identity: Bytes<32>, 
        tokenIn: CoinInfo, 
        tokenOut: CoinInfo,
        to: Either<ZswapCoinPublicKey, ContractAddress>
    ): [] {
        if (tokenIn.value > 0) {
            const reserveInType = LunarswapLibrary_getIdentity(identity, tokenIn.color, false);
            reserves.insert_coin(
                reserveInType,
                merge_coin_immediate(
                    reserves.lookup(reserveInType),
                    tokenIn
                ),
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        } else if (tokenOut.value > 0) {
            const reserveOutType = LunarswapLibrary_getIdentity(identity, tokenOut.color, false);   
            reserves.insert_coin(
                reserveOutType, 
                merge_coin_immediate(
                    reserves.lookup(reserveOutType), 
                    tokenOut
                ), 
                right<ZswapCoinPublicKey, ContractAddress>(kernel.self())
            );
        } else {
            assert (false) "LunarswapFactory: swapReserves() - Invalid token";
        }
        
        return [];
    }
    
    /**
     * @title createPair circuit
     * @description Creates a new trading pair for the given tokens.
     * 
     * @remarks
     * This circuit initializes a new trading pair with zero reserves and stores it
     * in the liquidity pool. The pair is identified by a unique hash generated from
     * the sorted token colors.
     *
     * Requirements:
     * - The token colors must be valid (non-zero)
     * - The pair must not already exist
     *
     * @circuitInfo k=11, rows=1500
     *
     * @param {Bytes<32>} identity - The unique identity hash for the new pair.
     * @param {CoinInfo} token0    - The first token in the pair.
     * @param {CoinInfo} token1    - The second token in the pair.
     *
     * @throws {Error} "LunarswapFactory: Invalid token color" if either token color is zero.
     *
     * @returns {Pair} - The created pair.
     */
    export circuit createPair(identity: Bytes<32>, token0: CoinInfo, token1: CoinInfo): Pair {
        // TODO: I am not sure if the Coin.Color can be set to zero.
        assert (!Utils_isKeyOrAddressZero(right<ZswapCoinPublicKey, ContractAddress>( ContractAddress { bytes: token0.color }))) "LunarswapFactory: Invalid token color";
        const pair = LunarswapPair_initializePair(identity, token0, token1); 
        pool.insert(identity, pair);
        return pair;
    } 

    /**
     * @title updatePair circuit
     * @description Updates an existing trading pair with new data.
     * 
     * @remarks
     * This circuit updates the pair data in the liquidity pool. The pair must already
     * exist for this operation to succeed.
     *
     * Requirements:
     * - The pair must already exist in the liquidity pool
     *
     * @circuitInfo k=11, rows=1000
     *
     * @param {Pair} pair     - The updated pair data.
     * @param {Bytes<32>} identity          - The unique identity hash of the pair.
     *
     * @throws {Error} "LunarswapFactory: updatePair() - Pair does not exist" if the pair doesn't exist.
     *
     * @returns {Pair} - The updated pair data.
     */
    export circuit updatePair(identity: Bytes<32>, pair: Pair): Pair {
        assert (isIdentityExists(identity)) "LunarswapFactory: updatePair() - Pair does not exist";
        pool.insert(identity, disclose(pair));
        return pair;
    }

    /**
     * @title removePair circuit
     * @description Removes a trading pair from the liquidity pool.
     * 
     * @remarks
     * This circuit removes a pair from the liquidity pool based on the pair's
     * token information. The pair must exist for this operation to succeed.
     *
     * Requirements:
     * - The pair must exist in the liquidity pool
     *
     * @circuitInfo k=11, rows=800
     *
     * @param {Pair} pair - The pair to remove.
     *
     * @throws {Error} "LunarswapFactory: removePair() - Pair does not exist" if the pair doesn't exist.
     *
     * @returns [] - No return values.
     */
    export circuit removePair(pair: Pair): [] {
        const identity = LunarswapLibrary_getIdentity(pair.token0Type, pair.token1Type, true);
        assert (isIdentityExists(identity)) "LunarswapFactory: removePair() - Pair does not exist";
        return pool.remove(identity);
    }
}
